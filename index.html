<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Valve Case Viewer (3MF/STL)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #app { display: grid; grid-template-columns: 320px 1fr; grid-template-rows: auto 1fr; height: 100%; }
    header { grid-column: 1 / 3; padding: 10px 14px; border-bottom: 1px solid #eee; display: flex; align-items: center; gap: 10px; }
    header h1 { font-size: 16px; margin: 0; }
    #sidebar { padding: 12px; border-right: 1px solid #eee; overflow: auto; display:flex; flex-direction:column; gap:14px; }
    #viewer { position: relative; background: #fafafa; }
    #canvas { position: absolute; inset: 0; }
    .block { margin-bottom: 0; }
    .label { font-size: 12px; color: #666; margin-bottom: 6px; }
    select, button, input[type="checkbox"] { font-size: 14px; }
    .file-item { display: flex; align-items: center; gap: 8px; margin: 4px 0; }
    .file-item label { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .toolbar { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .pill { border: 1px solid #ddd; padding: 6px 10px; border-radius: 999px; background: #fff; cursor: pointer; }
    .loading { position: absolute; top: 12px; right: 12px; background: rgba(255,255,255,0.95); border: 1px solid #ddd; border-radius: 8px; padding: 6px 10px; font-size: 12px; display: none; }
    footer { padding: 8px 12px; font-size: 12px; color: #888; border-top: 1px solid #eee; }
    .sep { width:1px; height:22px; background:#e5e5e5; margin:0 6px; }
    label.toggle { display:flex; align-items:center; gap:6px; padding:4px 10px; border:1px solid #ddd; border-radius:999px; background:#fff; cursor:pointer; }
    .legend { font-size:12px; border:1px solid #eee; border-radius:8px; padding:8px; background:#fff; }
    .legend .row { display:flex; justify-content:space-between; gap:10px; }
    .sw { width:12px; height:12px; border-radius:3px; display:inline-block; border:1px solid #ddd; margin-right:6px; vertical-align:-2px; }
    .sw.x { background:#ff4d4d; }  /* X red */
    .sw.y { background:#1ac41a; }  /* Y green */
    .sw.z { background:#2c72ff; }  /* Z blue */
    .metrics { font-size:13px; line-height:1.5; border:1px solid #eee; border-radius:8px; padding:10px; background:#fff; }
    .metrics .row { display:flex; justify-content:space-between; gap:8px; }
    .metrics .row + .row { margin-top:6px; }
    .metrics .small { color:#666; font-size:12px; }
    .grow { flex:1 1 auto; }
  </style>

  <!-- Shim + import map -->
  <script async src="https://ga.jspm.io/npm:es-module-shims@1.9.0/dist/es-module-shims.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
    }
  }
  </script>

  <link rel="icon" href="data:,">
</head>
<body>
  <div id="app">
    <header>
      <h1>Veryan Valve Viewer</h1>
      <div class="toolbar">
        <button class="pill" id="fitBtn">Fit visible</button>
        <button class="pill" id="showAllBtn">Show all</button>
        <button class="pill" id="hideAllBtn">Hide all</button>
        <button class="pill" id="resetBtn">Reset view</button>
        <div class="sep"></div>
        <label class="toggle"><input type="checkbox" id="meshToggle"> Show mesh</label>
        <label class="toggle"><input type="checkbox" id="axesToggle"> Show axes</label>
      </div>
      <div style="margin-left:auto; font-size:12px; color:#777;">
        Rotate: left-drag • Pan: right-drag • Zoom: wheel
      </div>
    </header>

    <aside id="sidebar">
      <div class="block">
        <div class="label">Case</div>
        <select id="caseSelect"></select>
      </div>

      <div class="block">
        <div class="label">Objects in this case (tick to show)</div>
        <div id="filesList"></div>
      </div>

      <div class="block">
        <div class="label">Measurements <span class="small">(mm)</span></div>
        <div class="metrics" id="metricsBox">
          <div class="row"><span>Visible splines</span><strong id="m_rings">–</strong></div>
          <div class="row"><span>Total axial length</span><strong id="m_axial_total">–</strong></div>
          <div class="row"><span>Spline spacing (min / max)</span><strong id="m_axial_minmax">–</strong></div>
          <div class="row"><span>Max diameter (⊥ axis)</span><strong id="m_diam">–</strong></div>
          <div class="row"><span>Perimeter (min / max)</span><strong id="m_perim_minmax">–</strong></div>
          <div class="row small"><span>Bounding box (W×D×H)</span><span id="m_bbox">–</span></div>
        </div>
      </div>

      <div class="grow"></div> <!-- pushes legend to bottom -->

      <div class="block">
        <div class="label">Axes legend (patient coordinates)</div>
        <div class="legend">
          <div class="row"><div><span class="sw x"></span><strong>X</strong></div><div>Left (−) ↔ Right (+)</div></div>
          <div class="row"><div><span class="sw y"></span><strong>Y</strong></div><div>Anterior (−) ↔ Posterior (+)</div></div>
          <div class="row"><div><span class="sw z"></span><strong>Z</strong></div><div>Inferior (−) ↔ Superior (+)</div></div>
        </div>
      </div>

      <footer>Tip: if something looks tiny or huge, click “Fit visible”.</footer>
    </aside>

    <main id="viewer">
      <div id="canvas"></div>
      <div class="loading" id="loading">Loading…</div>
    </main>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";
    import { STLLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/STLLoader.js";
    import { ThreeMFLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/3MFLoader.js";

    // --- Units ---
    const UNIT_SCALE = 1; // Model units → mm

    // UI
    const caseSelect = document.getElementById('caseSelect');
    const filesList  = document.getElementById('filesList');
    const loadingEl  = document.getElementById('loading');
    const fitBtn     = document.getElementById('fitBtn');
    const showAllBtn = document.getElementById('showAllBtn');
    const hideAllBtn = document.getElementById('hideAllBtn');
    const resetBtn   = document.getElementById('resetBtn');
    const meshToggle = document.getElementById('meshToggle');
    const axesToggle = document.getElementById('axesToggle');

    // metrics els
    const m_rings = document.getElementById('m_rings');
    const m_axial_total = document.getElementById('m_axial_total');
    const m_axial_minmax = document.getElementById('m_axial_minmax');
    const m_diam = document.getElementById('m_diam');
    const m_perim_minmax = document.getElementById('m_perim_minmax');
    const m_bbox = document.getElementById('m_bbox');

    // Three.js basics
    const container = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf8f9fb);

    const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 10000);
    camera.position.set(150, 150, 150);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff, 0.9));
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(1,1,1);
    scene.add(dir);

    const stlLoader = new STLLoader();
    const mfLoader  = new ThreeMFLoader();

    let currentGroup = null;
    let tubeMesh = null;
    let axesHelper = null, originDot = null;
    const items = []; // {name, object3D, checkbox}

    function randomColor() {
      const hues = [0, 40, 200];
      const h = hues[Math.floor(Math.random() * hues.length)];
      return new THREE.Color().setHSL(h/360, 0.5, 0.55);
    }

    function disposeMesh(mesh) {
      if (mesh?.geometry) mesh.geometry.dispose();
      if (mesh?.material?.dispose) mesh.material.dispose();
    }

    function clearScene() {
      if (tubeMesh) { disposeMesh(tubeMesh); scene.remove(tubeMesh); tubeMesh = null; }
      if (axesHelper) { scene.remove(axesHelper); axesHelper = null; }
      if (originDot) { disposeMesh(originDot); scene.remove(originDot); originDot = null; }
      if (!currentGroup) return;
      scene.remove(currentGroup);
      currentGroup.traverse(n => {
        if (n.isMesh) {
          n.geometry && n.geometry.dispose();
          n.material?.dispose && n.material.dispose();
        }
      });
      currentGroup = null;
      items.length = 0;
      filesList.innerHTML = "";
    }

    function fitToVisible(padding = 1.25) {
      const group = new THREE.Group();
      if (currentGroup) group.add(currentGroup.clone());
      if (tubeMesh && tubeMesh.visible) group.add(tubeMesh.clone());

      const box = new THREE.Box3().setFromObject(group);
      if (!isFinite(box.min.x) || !isFinite(box.max.x)) return;

      const size = new THREE.Vector3(); const center = new THREE.Vector3();
      box.getSize(size); box.getCenter(center);
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * Math.PI/180;
      const dist = Math.abs(maxDim / (2 * Math.tan(fov/2))) * padding;
      camera.position.set(center.x + dist, center.y + dist, center.z + dist);
      controls.target.copy(center);
      controls.update();

      if (axesToggle.checked) toggleAxes(true);
    }

    function addFileRow(labelText, object3D) {
      const row = document.createElement('div');
      row.className = 'file-item';
      const id = 'chk_' + Math.random().toString(36).slice(2);
      row.innerHTML = `
        <input id="${id}" type="checkbox" checked />
        <label for="${id}">${labelText}</label>
      `;
      const chk = row.querySelector('input');
      chk.addEventListener('change', () => {
        object3D.visible = chk.checked;
        if (meshToggle.checked) buildOrUpdateTube();
        if (axesToggle.checked) toggleAxes(true);
        updateMeasurements();
      });
      filesList.appendChild(row);
      items.push({ name: labelText, object3D, checkbox: chk });
    }

    function loadModel(url) {
      const ext = url.split('.').pop().toLowerCase();
      return new Promise((resolve, reject) => {
        if (ext === 'stl') {
          stlLoader.load(url, geom => {
            geom.computeVertexNormals();
            const mesh = new THREE.Mesh(
              geom,
              new THREE.MeshStandardMaterial({ color: randomColor(), metalness: 0.1, roughness: 0.75 })
            );
            resolve(mesh);
          }, undefined, reject);
        } else if (ext === '3mf') {
          mfLoader.load(url, obj => {
            obj.traverse(n => {
              if (n.isMesh) {
                if (!n.material) n.material = new THREE.MeshStandardMaterial({ color: randomColor(), metalness: 0.1, roughness: 0.75 });
                n.castShadow = n.receiveShadow = false;
              }
            });
            resolve(obj);
          }, undefined, reject);
        } else {
          reject(new Error('Unsupported file: ' + ext));
        }
      });
    }

    async function loadCase(entry) {
      loadingEl.style.display = 'block';
      clearScene();

      const group = new THREE.Group();
      group.name = entry.id;

      for (const fname of entry.files) {
        const url = entry.basePath + fname;
        try {
          const obj = await loadModel(url);
          obj.name = fname;
          obj.visible = true; // start visible
          group.add(obj);
          addFileRow(fname, obj);
        } catch (e) {
          console.error('Failed to load', url, e);
        }
      }

      scene.add(group);
      currentGroup = group;
      if (meshToggle.checked) buildOrUpdateTube();
      if (axesToggle.checked) toggleAxes(true);
      fitToVisible();
      updateMeasurements();
      loadingEl.style.display = 'none';
    }

    // ---------- ring geometry helpers ----------
    function getWorldVertices(object3D) {
      const verts = [];
      const v = new THREE.Vector3();
      object3D.updateWorldMatrix(true, true);
      object3D.traverse(n => {
        if (n.isMesh && n.geometry?.attributes?.position) {
          const pos = n.geometry.attributes.position;
          for (let i = 0; i < pos.count; i++) {
            v.fromBufferAttribute(pos, i).applyMatrix4(n.matrixWorld);
            verts.push(v.clone());
          }
        }
      });
      return verts;
    }

    function estimateRingNormal(object3D) {
      const normal = new THREE.Vector3(0,0,0);
      const a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
      const cb = new THREE.Vector3(), ab = new THREE.Vector3();
      object3D.updateWorldMatrix(true, true);
      object3D.traverse(n => {
        if (n.isMesh && n.geometry?.attributes?.position) {
          const pos = n.geometry.attributes.position;
          for (let i = 0; i < pos.count - 2; i += 3) {
            a.fromBufferAttribute(pos, i    ).applyMatrix4(n.matrixWorld);
            b.fromBufferAttribute(pos, i + 1).applyMatrix4(n.matrixWorld);
            c.fromBufferAttribute(pos, i + 2).applyMatrix4(n.matrixWorld);
            cb.subVectors(c, b);
            ab.subVectors(a, b);
            cb.cross(ab);
            normal.add(cb);
          }
        }
      });
      if (normal.length() < 1e-6) normal.set(0,0,1);
      return normal.normalize();
    }

    function dominantAxis(centers) {
      const mean = centers.reduce((acc,p)=>acc.add(p), new THREE.Vector3()).multiplyScalar(1/centers.length);
      let xx=0,xy=0,xz=0, yy=0,yz=0, zz=0;
      for (const p of centers) {
        const d = p.clone().sub(mean);
        xx += d.x*d.x; xy += d.x*d.y; xz += d.x*d.z;
        yy += d.y*d.y; yz += d.y*d.z; zz += d.z*d.z;
      }
      const C = new THREE.Matrix3().set(xx,xy,xz, xy,yy,yz, xz,yz,zz);
      let v = new THREE.Vector3(1,0,0);
      for (let i=0;i<12;i++){
        const e=C.elements;
        const nx = e[0]*v.x + e[1]*v.y + e[2]*v.z;
        const ny = e[3]*v.x + e[4]*v.y + e[5]*v.z;
        const nz = e[6]*v.x + e[7]*v.y + e[8]*v.z;
        v.set(nx,ny,nz).normalize();
      }
      return v.length()<1e-6 ? new THREE.Vector3(0,0,1) : v.normalize();
    }

    function orderRingVertices(verts, center, planeN) {
      // choose U from world X projected to ring plane; fallback to Y
      let U = new THREE.Vector3(1,0,0).sub(planeN.clone().multiplyScalar(planeN.x));
      if (U.length() < 1e-6) U = new THREE.Vector3(0,1,0).sub(planeN.clone().multiplyScalar(planeN.y));
      U.normalize();
      const V = new THREE.Vector3().crossVectors(planeN, U).normalize();

      const pts = verts.map(p => {
        const d = p.clone().sub(center);
        const x = d.dot(U), y = d.dot(V);
        const ang = Math.atan2(y, x);
        return { p3: p, x, y, ang };
      });

      pts.sort((a,b) => a.ang - b.ang);
      return { ordered3D: pts.map(t=>t.p3), U, V };
    }

    function resampleLoop(points3D, N) {
      const M = points3D.length;
      if (M === 0) return [];
      const out = new Array(N);
      for (let i=0;i<N;i++){
        const t = i * M / N;
        const i0 = Math.floor(t) % M;
        const i1 = (i0 + 1) % M;
        const f = t - Math.floor(t);
        const p = new THREE.Vector3().copy(points3D[i0]).lerp(points3D[i1], f);
        out[i] = p;
      }
      return out;
    }

    function bestShift(A, B) {
      const n = A.length;
      let bestS = 0, bestCost = Infinity;
      for (let s=0;s<n;s++){
        let cost = 0;
        for (let i=0;i<n;i++){
          const b = B[(i+s)%n];
          const dx=A[i].x-b.x, dy=A[i].y-b.y, dz=A[i].z-b.z;
          cost += dx*dx+dy*dy+dz*dz;
        }
        if (cost < bestCost) { bestCost = cost; bestS = s; }
      }
      return bestS;
    }

    // ---------- tube builder ----------
    const SAMPLE_SEGMENTS = 256;

    function buildOrUpdateTube() {
      if (tubeMesh) { disposeMesh(tubeMesh); scene.remove(tubeMesh); tubeMesh = null; }
      if (!meshToggle.checked) { if (axesToggle.checked) toggleAxes(true); return; }

      const ringObjs = items.filter(it => it.object3D.visible).map(it => it.object3D);
      if (ringObjs.length < 2) { if (axesToggle.checked) toggleAxes(true); return; }

      const ringData = ringObjs.map(obj => {
        const verts = getWorldVertices(obj);
        if (!verts.length) return null;
        const center = verts.reduce((acc,p)=>acc.add(p), new THREE.Vector3()).multiplyScalar(1/verts.length);
        const n = estimateRingNormal(obj);
        const ordered = orderRingVertices(verts, center, n);
        const samples = resampleLoop(ordered.ordered3D, SAMPLE_SEGMENTS);
        return { obj, center, n, samples };
      }).filter(Boolean);

      if (ringData.length < 2) { if (axesToggle.checked) toggleAxes(true); return; }

      const axis = dominantAxis(ringData.map(r => r.center));
      ringData.sort((a,b) => a.center.dot(axis) - b.center.dot(axis));

      const segs = SAMPLE_SEGMENTS;
      const gaps = ringData.length - 1;
      const triVerts = gaps * segs * 6;
      const pos = new Float32Array(triVerts * 3);
      let ptr = 0;
      const pushTri = (p1,p2,p3) => {
        pos[ptr++]=p1.x; pos[ptr++]=p1.y; pos[ptr++]=p1.z;
        pos[ptr++]=p2.x; pos[ptr++]=p2.y; pos[ptr++]=p2.z;
        pos[ptr++]=p3.x; pos[ptr++]=p3.y; pos[ptr++]=p3.z;
      };

      for (let i=0;i<ringData.length-1;i++){
        const A = ringData[i].samples;
        const B = ringData[i+1].samples;
        const s = bestShift(A,B);
        for (let j=0;j<segs;j++){
          const jn = (j+1)%segs;
          const b0 = B[(j+s)%segs];
          const b1 = B[(jn+s)%segs];
          pushTri(A[j], A[jn], b0);
          pushTri(b0, A[jn], b1);
        }
      }

      const g = new THREE.BufferGeometry();
      g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      g.computeVertexNormals();

      const m = new THREE.MeshStandardMaterial({
        color: 0x9b1b1b,
        transparent: true,
        opacity: 0.35,
        metalness: 0.0,
        roughness: 0.9,
        side: THREE.DoubleSide
      });

      tubeMesh = new THREE.Mesh(g, m);
      tubeMesh.name = 'tubeMesh';
      scene.add(tubeMesh);

      if (axesToggle.checked) toggleAxes(true);
      updateMeasurements();
    }

    // ---------- axes that follow the visible geometry ----------
    function getVisibleCenterAndSize() {
      const group = new THREE.Group();
      if (currentGroup) group.add(currentGroup.clone());
      if (tubeMesh && tubeMesh.visible) group.add(tubeMesh.clone());
      const box = new THREE.Box3().setFromObject(group);
      if (!isFinite(box.min.x) || !isFinite(box.max.x)) return null;
      const size = new THREE.Vector3(); const center = new THREE.Vector3();
      box.getSize(size); box.getCenter(center);
      return { center, size, box };
    }

    function toggleAxes(on) {
      if (on) {
        const info = getVisibleCenterAndSize();
        const len = info ? Math.max(info.size.x, info.size.y, info.size.z) * 0.25 : 40;
        const pos = info ? info.center : new THREE.Vector3(0,0,0);

        if (axesHelper) { scene.remove(axesHelper); axesHelper = null; }
        axesHelper = new THREE.AxesHelper(len);
        axesHelper.position.copy(pos);
        axesHelper.renderOrder = 999;
        axesHelper.traverse(o => { if (o.material) { o.material.depthTest = false; o.material.transparent = true; o.material.opacity = 0.9; }});
        scene.add(axesHelper);

        if (originDot) { disposeMesh(originDot); scene.remove(originDot); originDot = null; }
        const geo = new THREE.SphereGeometry(len * 0.02, 16, 12);
        const mat = new THREE.MeshBasicMaterial({ color: 0x222222, depthTest: false });
        originDot = new THREE.Mesh(geo, mat);
        originDot.position.copy(pos);
        originDot.renderOrder = 1000;
        scene.add(originDot);
      } else {
        if (axesHelper) { scene.remove(axesHelper); axesHelper = null; }
        if (originDot) { disposeMesh(originDot); scene.remove(originDot); originDot = null; }
      }
    }

    // ---------- formatting & measurements ----------
    function fmt2(v) { return isFinite(v) ? Number(v).toFixed(2) : "–"; }

    function updateMeasurements() {
      // visible splines (3MF/STL objects toggled on)
      const ringObjs = items.filter(it => it.object3D.visible).map(it => it.object3D);
      m_rings.textContent = ringObjs.length;

      // bbox of everything visible (splines + mesh)
      const info = getVisibleCenterAndSize();
      if (!info) {
        m_axial_total.textContent = m_axial_minmax.textContent = m_diam.textContent = m_perim_minmax.textContent = m_bbox.textContent = "–";
        return;
      }
      const size = info.size.clone().multiplyScalar(UNIT_SCALE);
      m_bbox.textContent = `${fmt2(size.x)} × ${fmt2(size.y)} × ${fmt2(size.z)}`;

      // centers & axis for spacing
      const centers = ringObjs.map(o => {
        const verts = getWorldVertices(o);
        return verts.reduce((acc,p)=>acc.add(p), new THREE.Vector3()).multiplyScalar(1/verts.length);
      });
      if (centers.length >= 2) {
        const axis = dominantAxis(centers);
        const t = centers.map(c => c.dot(axis)).sort((a,b)=>a-b);
        const diffs = [];
        for (let i=0;i<t.length-1;i++) diffs.push((t[i+1]-t[i]) * UNIT_SCALE);
        const total = (t[t.length-1]-t[0]) * UNIT_SCALE;
        m_axial_total.textContent = fmt2(total);
        m_axial_minmax.textContent = `${fmt2(Math.min(...diffs))} / ${fmt2(Math.max(...diffs))}`;
      } else {
        m_axial_total.textContent = m_axial_minmax.textContent = "–";
      }

      // true perimeters and per-spline max diameter (in their own planes)
      let perims = [];
      let ringMaxDiam = 0;

      const SAMPLE_MEAS = 512; // higher sampling for measurement accuracy
      for (const o of ringObjs) {
        const verts = getWorldVertices(o);
        if (!verts.length) continue;
        const center = verts.reduce((acc,p)=>acc.add(p), new THREE.Vector3()).multiplyScalar(1/verts.length);
        const n = estimateRingNormal(o);
        const ordered = orderRingVertices(verts, center, n);
        const smp = resampleLoop(ordered.ordered3D, SAMPLE_MEAS);

        // perimeter (sum of edge lengths around closed loop)
        let peri = 0;
        for (let i=0;i<smp.length;i++) {
          const a = smp[i], b = smp[(i+1)%smp.length];
          peri += a.distanceTo(b);
        }
        perims.push(peri * UNIT_SCALE);

        // max diameter (within this spline loop)
        let md = 0;
        for (let i=0;i<smp.length;i++) {
          const ai = smp[i];
          for (let j=i+1;j<smp.length;j++) {
            const d = ai.distanceTo(smp[j]);
            if (d>md) md = d;
          }
        }
        if (md > ringMaxDiam) ringMaxDiam = md;
      }

      if (perims.length) {
        const pMin = Math.min(...perims), pMax = Math.max(...perims);
        m_perim_minmax.textContent = `${fmt2(pMin)} / ${fmt2(pMax)}`;
        m_diam.textContent = fmt2(ringMaxDiam * UNIT_SCALE);
      } else {
        m_perim_minmax.textContent = m_diam.textContent = "–";
      }
    }

    // ---------- init & UI wiring ----------
    async function init() {
      const res = await fetch('cases.json', { cache: 'no-store' });
      const data = await res.json();

      data.cases.forEach((c, i) => {
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = c.name || c.id;
        caseSelect.appendChild(opt);
      });

      await loadCase(data.cases[0]);

      caseSelect.addEventListener('change', () => {
        const idx = parseInt(caseSelect.value, 10);
        loadCase(data.cases[idx]);
      });

      fitBtn.addEventListener('click', () => { fitToVisible(); updateMeasurements(); });
      showAllBtn.addEventListener('click', () => {
        items.forEach(it => { it.object3D.visible = true; it.checkbox.checked = true; });
        if (meshToggle.checked) buildOrUpdateTube();
        if (axesToggle.checked) toggleAxes(true);
        fitToVisible();
        updateMeasurements();
      });
      hideAllBtn.addEventListener('click', () => {
        items.forEach(it => { it.object3D.visible = false; it.checkbox.checked = false; });
        if (meshToggle.checked) buildOrUpdateTube();
        if (axesToggle.checked) toggleAxes(true);
        updateMeasurements();
      });
      resetBtn.addEventListener('click', () => {
        camera.position.set(150,150,150);
        controls.target.set(0,0,0);
        controls.update();
        if (axesToggle.checked) toggleAxes(true);
        fitToVisible();
        updateMeasurements();
      });

      meshToggle.addEventListener('change', () => {
        buildOrUpdateTube();
        fitToVisible();
        updateMeasurements();
      });
      axesToggle.addEventListener('change', () => {
        toggleAxes(axesToggle.checked);
      });
    }

    // Resize handling
    function onResize() {
      const w = container.clientWidth, h = container.clientHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);

    // Render loop
    (function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    })();

    init().catch(err => {
      loadingEl.style.display = 'none';
      alert('Could not start viewer. Check cases.json and file paths.');
      console.error(err);
    });
  </script>
</body>
</html>
